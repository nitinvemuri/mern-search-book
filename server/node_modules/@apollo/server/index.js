"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const caching_1 = require("./caching");
const utilities_1 = require("./utilities");
const execution_1 = require("./execution");
const apollo_tools_1 = require("@apollographql/apollo-tools");
var graphql_tag_1 = require("graphql-tag");
exports.gql = graphql_tag_1.default;
class ApolloServer {
    constructor(config) {
        this.config = config;
        this.plugins = [];
        this.toDispose = new Set();
        if (!config)
            throw new Error('ApolloServer requires options.');
        this.userContext = this.config.context;
        this.ensurePluginInstantiation(this.config.plugins);
        if (!this.config.modules) {
            throw new Error("TODO: No modules were specified.");
        }
        const { schema, errors } = apollo_tools_1.buildServiceDefinition(this.config.modules);
        if (errors && errors.length > 0) {
            throw new Error(errors.map(error => error.message).join('\n\n'));
        }
        if (!schema) {
            throw new Error("TODO: No schema.");
        }
        this.schemaDerivedData = this.generateSchemaDerivedData(schema);
    }
    async generateSchemaDerivedData(schema) {
        const documentStore = this.initializeDocumentStore();
        return {
            schema,
            documentStore,
        };
    }
    async willStart() {
        const { schema } = await this.schemaDerivedData;
        await Promise.all(this.plugins.map(plugin => plugin.serverWillStart &&
            plugin.serverWillStart({
                schema: schema,
                schemaHash: 'TODO',
                engine: {},
            })));
    }
    async stop() {
        this.toDispose.forEach(dispose => dispose());
    }
    ensurePluginInstantiation(plugins) {
        if (!plugins || !plugins.length) {
            return;
        }
        this.plugins = plugins.map(plugin => {
            if (typeof plugin === 'function') {
                return plugin();
            }
            return plugin;
        });
    }
    initializeDocumentStore() {
        return new caching_1.InMemoryLRUCache({
            maxSize: Math.pow(2, 20) * 30,
            sizeCalculator: utilities_1.approximateObjectSize,
        });
    }
    async graphQLServerOptions(integrationContextArgument) {
        const { schema, documentStore } = await this.schemaDerivedData;
        let context;
        try {
            context =
                typeof this.userContext === 'function'
                    ? await this.userContext(integrationContextArgument || Object.create(null))
                    : this.userContext || Object.create(null);
        }
        catch (error) {
            context = () => {
                throw error;
            };
        }
        return {
            schema,
            plugins: this.plugins,
            documentStore,
            context,
        };
    }
    async executeOperation(request) {
        let options;
        try {
            options = await this.graphQLServerOptions();
        }
        catch (e) {
            e.message = `Invalid options provided to ApolloServer: ${e.message}`;
            throw new Error(e);
        }
        if (typeof options.context === 'function') {
            options.context = options.context();
        }
        const requestCtx = {
            request,
            context: options.context || Object.create(null),
            cache: options.cache,
            response: {},
        };
        return execution_1.processGraphQLRequest(options, requestCtx);
    }
}
exports.ApolloServer = ApolloServer;
//# sourceMappingURL=index.js.map